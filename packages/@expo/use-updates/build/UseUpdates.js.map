{"version":3,"file":"UseUpdates.js","sourceRoot":"","sources":["../src/UseUpdates.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Updates from 'expo-updates';\nimport { useEffect, useState } from 'react';\n\nimport { UseUpdatesStateType, UseUpdatesReturnType, UseUpdatesEventType } from './UseUpdates.types';\nimport {\n  emitUseUpdatesEvent,\n  useUpdateEvents,\n  addUpdatesStateChangeListener,\n} from './UseUpdatesEmitter';\nimport {\n  currentlyRunning,\n  availableUpdateFromContext,\n  downloadedUpdateFromContext,\n} from './UseUpdatesUtils';\n\n/**\n * Calls [`Updates.checkForUpdateAsync()`](https://docs.expo.dev/versions/latest/sdk/updates/#updatescheckforupdateasync)\n * and refreshes the `availableUpdate` property with the result.\n * If an error occurs, the `error` property will be set.\n */\nexport const checkForUpdate = () => {\n  Updates.checkForUpdateAsync();\n};\n/**\n * Downloads an update, if one is available, using\n * [`Updates.fetchUpdateAsync()`](https://docs.expo.dev/versions/latest/sdk/updates/#updatesfetchupdateasync).\n * This should not be called unless `isUpdateAvailable` is true.\n * If an error occurs, the `error` property will be set.\n */\nexport const downloadUpdate = () => {\n  Updates.fetchUpdateAsync();\n};\n\n/**\n * Runs an update by calling [`Updates.reloadAsync()`](https://docs.expo.dev/versions/latest/sdk/updates/#updatesreloadasync).\n * This instructs the app to reload using the most recently downloaded version.\n * This is useful for triggering a newly downloaded update to launch without the user needing to manually restart the app.\n * This should not be called unless there is an available update\n * that has already been successfully downloaded (`isUpdatePending` is true).\n * If an error occurs, the `error` property will be set.\n */\nexport const runUpdate = () => {\n  Updates.reloadAsync();\n};\n\n/**\n * Calls `Updates.readLogEntriesAsync()` and sets the `logEntries` property to the results.\n * If an error occurs, the `error` property will be set.\n *\n * @param maxAge Max age of log entries to read, in ms. Defaults to 3600000 (1 hour).\n */\nexport const readLogEntries: (maxAge?: number) => void = (maxAge: number = 3600000) => {\n  Updates.readLogEntriesAsync(maxAge)\n    .then((logEntries) => {\n      emitUseUpdatesEvent({\n        type: UseUpdatesEventType.READ_LOG_ENTRIES_COMPLETE,\n        logEntries,\n      });\n    })\n    .catch((error) => {\n      emitUseUpdatesEvent({\n        type: UseUpdatesEventType.ERROR,\n        error,\n      });\n    });\n};\n\n/**\n * Hook that obtains information on available updates and on the currently running update.\n *\n * @return the structures with information on currently running and available updates.\n *\n * @example\n * ```tsx UpdatesDemo.tsx\n * import { StatusBar } from 'expo-status-bar';\n * import React from 'react';\n * import { Pressable, Text, View } from 'react-native';\n *\n * import type { UseUpdatesEvent } from '@expo/use-updates';\n * import {\n *   useUpdates,\n *   checkForUpdate,\n *   downloadUpdate,\n *   runUpdate,\n * } from '@expo/use-updates';\n *\n * export default function UpdatesDemo() {\n *   const { currentlyRunning, availableUpdate, isUpdateAvailable, isUpdatePending } = useUpdates();\n *\n *   React.useEffect(() => {\n *     if (isUpdatePending) {\n *       // Update has successfully downloaded\n *       runUpdate();\n *     }\n *   }, [isUpdatePending]);\n *\n *   // If true, we show the button to download and run the update\n *   const showDownloadButton = isUpdateAvailable;\n *\n *   // Show whether or not we are running embedded code or an update\n *   const runTypeMessage = currentlyRunning.isEmbeddedLaunch\n *     ? 'This app is running from built-in code'\n *     : 'This app is running an update';\n *\n *   return (\n *     <View style={styles.container}>\n *       <Text style={styles.headerText}>Updates Demo</Text>\n *       <Text>{runTypeMessage}</Text>\n *       <Button pressHandler={checkForUpdate} text=\"Check manually for updates\" />\n *       {showDownloadButton ? (\n *         <Button pressHandler={downloadUpdate} text=\"Download and run update\" />\n *       ) : null}\n *       <StatusBar style=\"auto\" />\n *     </View>\n *   );\n * }\n * ```\n */\nexport const useUpdates: () => UseUpdatesReturnType = () => {\n  const [updatesState, setUpdatesState] = useState<UseUpdatesStateType>({\n    isUpdateAvailable: false,\n    isUpdatePending: false,\n    isChecking: false,\n    isDownloading: false,\n  });\n\n  useEffect(() => {\n    const subscription = addUpdatesStateChangeListener((event) => {\n      setUpdatesState((updatesState) => {\n        if (event.context.isChecking) {\n          return {\n            ...updatesState,\n            isChecking: true,\n            lastCheckForUpdateTimeSinceRestart: new Date(),\n          };\n        }\n        const availableUpdate = availableUpdateFromContext(event.context);\n        const downloadedUpdate = downloadedUpdateFromContext(event.context);\n        return {\n          ...updatesState,\n          isUpdateAvailable: event.context.isUpdateAvailable,\n          isUpdatePending: event.context.isUpdatePending || availableUpdate?.isRollback || false,\n          isChecking: event.context.isChecking,\n          isDownloading: event.context.isDownloading,\n          availableUpdate,\n          downloadedUpdate,\n          error: event.context.checkError || event.context.downloadError,\n        };\n      });\n    });\n    return () => subscription.remove();\n  }, []);\n\n  // Set up listener for events from automatic update requests\n  // that happen on startup, and use events to refresh the updates info\n  // context\n  useUpdateEvents((event) => {\n    switch (event.type) {\n      case UseUpdatesEventType.ERROR:\n        setUpdatesState((updatesState) => ({\n          ...updatesState,\n          error: event.error,\n        }));\n        break;\n      case UseUpdatesEventType.READ_LOG_ENTRIES_COMPLETE:\n        setUpdatesState((updatesState) => ({\n          ...updatesState,\n          logEntries: event?.logEntries,\n        }));\n        break;\n      default:\n        break;\n    }\n  });\n\n  // Return the updates info and the user facing functions\n  return {\n    currentlyRunning,\n    ...updatesState,\n  };\n};\n"]}